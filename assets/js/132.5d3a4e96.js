(window.webpackJsonp=window.webpackJsonp||[]).push([[132],{409:function(t,e,a){"use strict";a.r(e);var v=a(4),_=Object(v.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"vue与react区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue与react区别"}},[t._v("#")]),t._v(" vue与react区别")]),t._v(" "),e("p",[t._v("vue致力解决的问题与react一致，但缺提供了另一套解决方案。vue使用模版系统(弱化jsx)，使其对现有应用的升级更加容易。这是因为模版用的就是普通的html，通过vue来整合现有系统是比较容易的，不需要整体重构。")]),t._v(" "),e("h3",{attrs:{id:"相似之处"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#相似之处"}},[t._v("#")]),t._v(" 相似之处")]),t._v(" "),e("ul",[e("li",[t._v("两者都是用于创建UI的JavaScript库；")]),t._v(" "),e("li",[t._v("两者都快速轻便；")]),t._v(" "),e("li",[t._v("都有基于组件的架构；")]),t._v(" "),e("li",[t._v("都是用虚拟DOM；")]),t._v(" "),e("li",[t._v("都可放入单个html文件中，或者成为更复杂webpack设置中的模块；")]),t._v(" "),e("li",[t._v("都有独立但常用的路由器和状态管理库；")])]),t._v(" "),e("p",[t._v("它们之间最大的区别是vue通常使用html模版文件，而react则完全是JavaScript。vue有双向绑定语法糖。")]),t._v(" "),e("h3",{attrs:{id:"不同之处"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不同之处"}},[t._v("#")]),t._v(" 不同之处")]),t._v(" "),e("h4",{attrs:{id:"_1、监听数据变化的实现原理不同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、监听数据变化的实现原理不同"}},[t._v("#")]),t._v(" 1、监听数据变化的实现原理不同")]),t._v(" "),e("p",[t._v("vue通过getter和setter以及一些函数的劫持，能精确知道数据的变化。")]),t._v(" "),e("p",[t._v("react默认是通过比较引用的方式(diff)进行的，如果不优化可能导致大量不必要的VDOM的重新渲染，为什么react不精确监听数据变化？这是因为vue和react设计理念的区别，vue使用的是可变数据，而react更强调数据的不可变，而二者没有好坏之分，vue更加简单，而react构建大型应用时更棒。")]),t._v(" "),e("h4",{attrs:{id:"_2、数据流的不同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、数据流的不同"}},[t._v("#")]),t._v(" 2、数据流的不同")]),t._v(" "),e("p",[t._v("Vue1.0中可以实现两种双向绑定：父子组件之间，props可以双向绑定；组件与DOM之间可以通过v-model双向绑定。"),e("br"),t._v("\nVue2.x中去掉了第一种，也就是父子组件之间不能双向绑定了（但是提供了一个语法糖自动帮你通过事件的方式修改），并且Vue2.x已经不鼓励组件对自己的 props进行任何修改了。")]),t._v(" "),e("p",[t._v("React一直不支持双向绑定，提倡的是单向数据流，称之为onChange/setState()模式。不过由于我们一般都会用Vuex以及Redux等单向数据流的状态管理框架。")]),t._v(" "),e("h4",{attrs:{id:"_3、hoc和mixins"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、hoc和mixins"}},[t._v("#")]),t._v(" 3、HOC和mixins")]),t._v(" "),e("p",[t._v("Vue组合不同功能的方式是通过mixin，Vue中组件是一个被包装的函数，并不简单的就是我们定义组件的时候传入的对象或者函数。比如我们定义的模板怎么被编译的？比如声明的props怎么接收到的？这些都是vue创建组件实例的时候隐式干的事。由于vue默默帮我们做了这么多事，所以我们自己如果直接把组件的声明包装一下，返回一个HoC，那么这个被包装的组件就无法正常工作了。")]),t._v(" "),e("p",[t._v("React组合不同功能的方式是通过HoC(高阶组件）。React最早也是使用mixins的，不过后来他们觉得这种方式对组件侵入太强会导致很多问题，就弃用了mixinx转而使用HoC。高阶组件本质就是高阶函数，React的组件是一个纯粹的函数，所以高阶函数对React来说非常简单。")]),t._v(" "),e("h4",{attrs:{id:"_4、组件通信的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、组件通信的区别"}},[t._v("#")]),t._v(" 4、组件通信的区别")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://s1.ax1x.com/2022/10/18/xsPPbV.jpg",alt:"xsPPbV.jpg"}})]),t._v(" "),e("p",[t._v("Vue中有三种方式可以实现组件通信：父组件通过props向子组件传递数据或者回调，虽然可以传递回调，但是我们一般只传数据；子组件通过事件向父组件发送消息；通过V2.2.0中新增的provide/inject来实现父组件向子组件注入数据，可以跨越多个层级。")]),t._v(" "),e("p",[e("RouterLink",{attrs:{to:"/vue_docs/Vue相关面试题.html#四、vue组件间的参数传"}},[t._v("vue组件通信")])],1),t._v(" "),e("p",[t._v("React中也有对应的三种方式：父组件通过props可以向子组件传递数据或者回调；可以通过 context 进行跨层级的通信，这其实和 provide/inject 起到的作用差不多。React 本身并不支持自定义事件，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数，但Vue更倾向于使用事件。在React中我们都是使用回调函数的，这可能是他们二者最大的区别。")]),t._v(" "),e("h4",{attrs:{id:"_5、模板渲染方式的不同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5、模板渲染方式的不同"}},[t._v("#")]),t._v(" 5、模板渲染方式的不同")]),t._v(" "),e("p",[t._v("在表层上，模板的语法不同，React是通过JSX渲染模板。而Vue是通过一种拓展的HTML语法进行渲染，但其实这只是表面现象，毕竟React并不必须依赖JSX。")]),t._v(" "),e("p",[t._v("在深层上，模板的原理不同，这才是他们的本质区别：React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的，更加纯粹更加原生。而Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现对这一点，这样的做法显得有些独特，会把HTML弄得很乱。")]),t._v(" "),e("h4",{attrs:{id:"_6、渲染过程不同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6、渲染过程不同"}},[t._v("#")]),t._v(" 6、渲染过程不同")]),t._v(" "),e("p",[t._v("Vue可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。")]),t._v(" "),e("p",[t._v("React在应用的状态被改变时，全部子组件都会重新渲染。通过shouldComponentUpdate这个生命周期方法可以进行控制，但Vue将此视为默认的优化。")]),t._v(" "),e("h4",{attrs:{id:"_7、框架本质不同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7、框架本质不同"}},[t._v("#")]),t._v(" 7、框架本质不同")]),t._v(" "),e("p",[t._v("Vue本质是MVVM框架，由MVC发展而来；")]),t._v(" "),e("p",[t._v("React是前端组件化框架，由后端组件化发展而来。")]),t._v(" "),e("h4",{attrs:{id:"_8、vuex和redux的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8、vuex和redux的区别"}},[t._v("#")]),t._v(" 8、Vuex和Redux的区别")]),t._v(" "),e("p",[t._v("从表面上来说，store注入和使用方式有一些区别。在Vuex中，store被直接注入到了组件实例中，因此可以比较灵活的使用：使用dispatch、commit提交更新，通过mapState或者直接通过this.store被直接注入到了组件实例中，因此可以比较灵活的使用：使用dispatch、commit提交更新，通过mapState或者直接通过this.store来读取数据。在Redux中，我们每一个组件都需要显示的用connect把需要的props和dispatch连接起来。另外，Vuex更加灵活一些，组件中既可以dispatch action，也可以commit updates，而Redux中只能进行dispatch，不能直接调用reducer进行修改。")]),t._v(" "),e("p",[t._v("从实现原理上来说，最大的区别是两点：Redux使用的是不可变数据，而Vuex的数据是可变的，因此，Redux每次都是用新state替换旧state，而Vuex是直接修改。Redux在检测数据变化的时候，是通过diff的方式比较差异的，而Vuex其实和Vue的原理一样，是通过getter/setter来比较的，这两点的区别，也是因为React和Vue的设计理念不同。React更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。因此也会给人一种大型项目用React，小型项目用Vue的感觉。")]),t._v(" "),e("h4",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("Vue的优势包括：")]),t._v(" "),e("ul",[e("li",[t._v("模板和渲染函数的弹性选择")]),t._v(" "),e("li",[t._v("简单的语法及项目创建")]),t._v(" "),e("li",[t._v("更快的渲染速度和更小的体积")])]),t._v(" "),e("p",[t._v("React的优势包括：")]),t._v(" "),e("ul",[e("li",[t._v("更适用于大型应用和更好的可测试性")]),t._v(" "),e("li",[t._v("同时适用于Web端和原生App")]),t._v(" "),e("li",[t._v("更大的生态圈带来的更多支持和工具")])]),t._v(" "),e("p",[t._v("而实际上，React和Vue都是非常优秀的框架，它们之间的相似之处多过不同之处，并且它们大部分最棒的功能是相通的：")]),t._v(" "),e("ul",[e("li",[t._v("利用虚拟DOM实现快速渲染")]),t._v(" "),e("li",[t._v("轻量级")]),t._v(" "),e("li",[t._v("响应式组件")]),t._v(" "),e("li",[t._v("服务器端渲染")]),t._v(" "),e("li",[t._v("易于集成路由工具，打包工具以及状态管理工具")]),t._v(" "),e("li",[t._v("优秀的支持和社区")])])])}),[],!1,null,null,null);e.default=_.exports}}]);