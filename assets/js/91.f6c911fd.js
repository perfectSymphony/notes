(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{446:function(t,s,v){"use strict";v.r(s);var a=v(45),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,v=t._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"前端性能优化点汇总"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前端性能优化点汇总"}},[t._v("#")]),t._v(" 前端性能优化点汇总")]),t._v(" "),v("blockquote",[v("p",[t._v("对于影响页面呈选 的因素有3个地方：服务器连接数据库并计算返回数据 ， http请求以及数据（文件）经过网络传输 ， 文件在浏览器中计算渲染呈选； 其中大约80%的时间都耗在了http请求上，所以要想大幅度优化页面，必须从http请求上入手")])]),t._v(" "),v("p",[t._v("chrome里面的Timeline工具能帮助我们分析从请求，到渲染，到绘制，最后在页面显示一系列动作的具体情况，对于前端优化作用非常大。")]),t._v(" "),v("h2",{attrs:{id:"一、减少请求数量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、减少请求数量"}},[t._v("#")]),t._v(" 一、减少请求数量")]),t._v(" "),v("p",[t._v("【合并】")]),t._v(" "),v("p",[t._v("如果不进行文件合并，有如下3个隐患")]),t._v(" "),v("p",[t._v("1、文件与文件之间有插入的上行请求，增加了N-1个网络延迟")]),t._v(" "),v("p",[t._v("2、受丢包问题影响更严重")]),t._v(" "),v("p",[t._v("3、经过代理服务器时可能会被断开")]),t._v(" "),v("p",[t._v("但是，文件合并本身也有自己的问题")]),t._v(" "),v("p",[t._v("1、首屏渲染问题")]),t._v(" "),v("p",[t._v("2、缓存失效问题")]),t._v(" "),v("p",[t._v("所以，对于文件合并，有如下改进建议")]),t._v(" "),v("p",[t._v("1、公共库合并")]),t._v(" "),v("p",[t._v("2、不同页面单独合并")]),t._v(" "),v("blockquote",[v("p",[t._v("将多个脚步合并为一个脚步，多个css文件合并为一个css文件，理想情况下：一个页面应该使用不多于一个的脚步和样式表。但这种将所有东西合并到一处的行为对于模块化编程思维来说是一种倒退，解决方法是遵守编译型语言的模式，开发模式下保持js文件的模块化，生成打包的时候生成一个目标文件部署到线上。")])]),t._v(" "),v("p",[t._v("【图片处理】")]),t._v(" "),v("p",[t._v("1、雪碧图")]),t._v(" "),v("p",[t._v("CSS雪碧图是以前非常流行的技术，把网站上的一些图片整合到一张单独的图片中，可以减少网站的HTTP请求数量，但是当整合图片比较大时，一次加载比较慢。随着字体图片、SVG图片的流行，该技术渐渐退出了历史舞台")]),t._v(" "),v("p",[t._v("2、Base64(是“负优化”效果)[已经不推荐使用了]")]),t._v(" "),v("p",[t._v("原因有以下3点：")]),t._v(" "),v("h4",{attrs:{id:"第一、让-css-文件的体积失去控制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第一、让-css-文件的体积失去控制"}},[t._v("#")]),t._v(" 第一、让 css 文件的体积失去控制")]),t._v(" "),v("p",[t._v("当你把图片转换为 base64 字符串之后，字符串的体积一般会比原图更大，一般会多出接近 3 成的大小，如果你一个页面中有 20 张平均大小为 50kb 的图片，转它们为 base64 后，你的 css 文件将可能增大 1.2mb 的大小，这样将严重阻碍浏览器的关键渲染路径：\n"),v("img",{attrs:{src:"https://s4.ax1x.com/2022/03/03/btvkdI.png",alt:"btvkdI.png"}})]),t._v(" "),v("p",[t._v("css 文件本身就是渲染阻塞资源，浏览器首次加载时如果没有全部下载和解析完 css 内容就无法进行渲染树的构建，而 base64 的嵌入则是雪上加霜，这将把原先浏览器可以进行优化的图片异步加载，变成首屏渲染的阻塞和延迟。")]),t._v(" "),v("p",[t._v("或许有人会说，webpack 的 url-loader 可以根据图片大小决定是否转为 base64(一般是小于 10kb 的图片)，但你也应该担心如果页面中有 100 张小于 10kb 的图片时，会给 css 文件增加多少体积。")]),t._v(" "),v("h4",{attrs:{id:"第二、让浏览器的资源缓存策略功亏一篑"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第二、让浏览器的资源缓存策略功亏一篑"}},[t._v("#")]),t._v(" 第二、让浏览器的资源缓存策略功亏一篑")]),t._v(" "),v("p",[t._v("假设你的 base64Url 会被你的应用多次复用，本来浏览器可以直接从本地缓存取出的图片，换成 base64Url，将造成应用中多个页面重复下载 1.3 倍大小的文本，假设一张图片是 100kb 大小，被你的应用使用了 10 次，那么造成的流量浪费将是:"),v("code",[t._v("(100 * 1.3 * 10)- 100 = 1200kb")]),t._v("。")]),t._v(" "),v("h4",{attrs:{id:"第三、低版本浏览器的兼容问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第三、低版本浏览器的兼容问题"}},[t._v("#")]),t._v(" 第三、低版本浏览器的兼容问题")]),t._v(" "),v("p",[t._v("这是比较次要的问题，dataurl 在低版本 IE 浏览器，比如 IE8 及以下的浏览器，会有兼容性问题")]),t._v(" "),v("h4",{attrs:{id:"第四、不利于开发者工具调试与查看"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第四、不利于开发者工具调试与查看"}},[t._v("#")]),t._v(" 第四、不利于开发者工具调试与查看")]),t._v(" "),v("p",[t._v("无论哪张图片，看上去都是一堆没有意义的字符串，光看代码无法知道原图是哪张，不利于某些情况下的比对。")]),t._v(" "),v("p",[t._v("说了这么多，有人可能不服气，既然这种方案缺点这么多，为啥它会从以前就被广泛使用呢？这要从早期的 http 协议特性说起，在 http1.1 之前，http 协议尚未实现 keep-alive，也就是每一次请求，都必须走三次握手四次挥手去建立连接，连接完又丢弃无法复用，而即使是到了 http1.1 的时代，keep-alive 可以保证 tcp 的长连接，不需要多次重新建立，但由于 http1.1 是基于文本分割的协议，所以消息是串行的，必须有序地逐个解析，所以在这种请求“昂贵”，且早期图片体积并不是特别大，用户对网页的响应速度和体验要求也不是很高的各种前提结合下，减少图片资源的请求数是可以理解的。")]),t._v(" "),v("p",[t._v("但是，在越来越多网站支持 http2.0 的前提下，这些都不是问题，h2 是基于二进制帧的协议，在保留 http1.1 长连接的前提下，实现了消息的并行处理，请求和响应可以交错甚至可以复用，多个并行请求的开销已经大大降低，我已经不知道还有什么理由继续坚持 base64Url 的使用了。")]),t._v(" "),v("p",[t._v("3、使用字体图标来代替图片")]),t._v(" "),v("p",[t._v("【减少重定向】")]),t._v(" "),v("p",[t._v("尽量避免使用重定向，当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载，降低了用户体验")]),t._v(" "),v("p",[t._v("如果一定要使用重定向，如http重定向到https，要使用301永久重定向，而不是302临时重定向。因为，如果使用302，则每一次访问http，都会被重定向到https的页面。而永久重定向，在第一次从http重定向到https之后 ，每次访问http，会直接返回https的页面")]),t._v(" "),v("p",[t._v("【使用缓存】")]),t._v(" "),v("p",[t._v("使用cach-control或expires这类强缓存时，缓存不过期的情况下，不向服务器发送请求。强缓存过期时，会使用last-modified或etag这类协商缓存，向服务器发送请求，如果资源没有变化，则服务器返回304响应，浏览器继续从本地缓存加载资源；如果资源更新了，则服务器将更新后的资源发送到浏览器，并返回200响应")]),t._v(" "),v("p",[t._v("【不使用CSS @import】")]),t._v(" "),v("p",[t._v("CSS的@import会造成额外的请求")]),t._v(" "),v("p",[t._v("【避免使用空的src和href】")]),t._v(" "),v("p",[t._v("a标签设置空的href，会重定向到当前的页面地址")]),t._v(" "),v("p",[t._v("form设置空的method，会提交表单到当前的页面地址")]),t._v(" "),v("h2",{attrs:{id:"二、减小资源大小"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、减小资源大小"}},[t._v("#")]),t._v(" 二、减小资源大小")]),t._v(" "),v("p",[t._v("【压缩】")]),t._v(" "),v("p",[t._v("1、HTML压缩")]),t._v(" "),v("p",[t._v("HTML代码压缩就是压缩在文本文件中有意义，但是在HTML中不显示的字符，包括空格，制表符，换行符等")]),t._v(" "),v("p",[t._v("2、CSS压缩")]),t._v(" "),v("p",[t._v("CSS压缩包括无效代码删除与CSS语义合并")]),t._v(" "),v("p",[t._v("3、JS压缩与混乱")]),t._v(" "),v("p",[t._v("JS压缩与混乱包括无效字符及注释的删除、代码语义的缩减和优化、降低代码可读性，实现代码保护")]),t._v(" "),v("p",[t._v("4、图片压缩")]),t._v(" "),v("p",[t._v("针对真实图片情况，舍弃一些相对无关紧要的色彩信息")]),t._v(" "),v("p",[t._v("【webp】")]),t._v(" "),v("p",[t._v("在安卓下可以使用webp格式的图片，它具有更优的图像数据压缩算法，能带来更小的图片体积，同等画面质量下，体积比jpg、png少了25%以上，而且同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性")]),t._v(" "),v("p",[t._v("【开启gzip】")]),t._v(" "),v("p",[t._v("HTTP协议上的GZIP编码是一种用来改进WEB应用程序性能的技术。大流量的WEB站点常常使用GZIP压缩技术来让用户感受更快的速度。这一般是指WWW服务器中安装的一个功能，当有人来访问这个服务器中的网站时，服务器中的这个功能就将网页内容压缩后传输到来访的电脑浏览器中显示出来。一般对纯文本内容可压缩到原大小的40%")]),t._v(" "),v("h2",{attrs:{id:"三、优化网络连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、优化网络连接"}},[t._v("#")]),t._v(" 三、优化网络连接")]),t._v(" "),v("p",[t._v("【使用CDN】")]),t._v(" "),v("p",[t._v("CDN全称是Content Delivery Network，即内容分发网络，它能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度")]),t._v(" "),v("p",[t._v("通常浏览器对于一个域名的并发请求是有限的，比如：有100个文件要加载，但浏览器一次只可能并发请求10个文件，这样并发多次就会耗时。因此配置多个域名能够最大限度的增加并发请求量，")]),t._v(" "),v("p",[t._v("但这里有个缺点就是会增加浏览器域名解析的次数，所以利用CDN来加载不是经常更新和修改的静态资源（图片，css库，js第三方库等等）。一个是CDN域名一般都会缓存到本地中，另一个是CDN网络请求速度是非常快的。")]),t._v(" "),v("p",[t._v("由于CDN部署在网络运营商的机房，这些运营商又是终端用户的网络服务提供商，因此用户请求路由的第一跳就到达了CDN服务器，当CDN中存在浏览器请求的资源时，从CDN直接返回给浏览器，最短路径返回响应，加快用户访问速度，减少数据中心负载压力。")]),t._v(" "),v("p",[t._v("【使用DNS预解析】")]),t._v(" "),v("p",[t._v("当浏览器访问一个域名的时候，需要解析一次DNS，获得对应域名的ip地址。在解析过程中，按照浏览器缓存、系统缓存、路由器缓存、ISP(运营商)DNS缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到IP地址")]),t._v(" "),v("p",[t._v("DNS Prefetch，即DNS预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，来提高网站的访问速度")]),t._v(" "),v("p",[t._v("方法是在 head 标签里面写上几个 link 标签")]),t._v(" "),v("div",{staticClass:"language-sh line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-sh"}},[v("code",[v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("link "),v("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("rel")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),v("span",{pre:!0,attrs:{class:"token string"}},[t._v('"dns-prefecth"')]),t._v(" "),v("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("href")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),v("span",{pre:!0,attrs:{class:"token string"}},[t._v('"https://www.google.com"')]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("link "),v("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("rel")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),v("span",{pre:!0,attrs:{class:"token string"}},[t._v('"dns-prefecth"')]),t._v(" "),v("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("href")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),v("span",{pre:!0,attrs:{class:"token string"}},[t._v('"https://www.google-analytics.com"')]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br")])]),v("p",[t._v("对以上几个网站提前解析 DNS，由于它是并行的，不会堵塞页面渲染，这样可以缩短资源加载的时间")]),t._v(" "),v("p",[t._v("【并行连接】")]),t._v(" "),v("p",[t._v("由于在HTTP1.1协议下，chrome每个域名的最大并发数是6个。使用多个域名，可以增加并发数")]),t._v(" "),v("p",[t._v("【持久连接】")]),t._v(" "),v("p",[t._v("使用keep-alive或presistent来建立持久连接，持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量")]),t._v(" "),v("p",[t._v("【管道化连接】")]),t._v(" "),v("p",[t._v("在HTTP2协议中，可以开启管道化连接，即单条连接的多路复用，每条连接中并发传输多个资源，这里就不需要添加域名来增加并发数了")]),t._v(" "),v("h2",{attrs:{id:"四、优化资源加载"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四、优化资源加载"}},[t._v("#")]),t._v(" 四、优化资源加载")]),t._v(" "),v("p",[t._v("【资源加载位置】")]),t._v(" "),v("p",[t._v("通过优化资源加载位置，更改资源加载时机，使尽可能快地展示出页面内容，尽可能快地使功能可用")]),t._v(" "),v("p",[t._v("1、CSS文件放在head中，先外链，后本页")]),t._v(" "),v("p",[t._v("2、JS文件放在body底部，先外链，后本页")]),t._v(" "),v("p",[t._v("3、处理页面、处理页面布局的JS文件放在head中，如babel-polyfill.js文件、flexible.js文件")]),t._v(" "),v("p",[t._v("4、body中间尽量不写style标签和script标签")]),t._v(" "),v("p",[t._v("【资源加载时机】")]),t._v(" "),v("p",[t._v("1、异步script标签")]),t._v(" "),v("p",[t._v("defer:  异步加载，在HTML解析完成后执行。defer的实际效果与将代码放在body底部类似")]),t._v(" "),v("p",[t._v("async: 异步加载，加载完成后立即执行")]),t._v(" "),v("p",[t._v("2、模块按需加载")]),t._v(" "),v("p",[t._v("在SPA等业务逻辑比较复杂的系统中，需要根据路由来加载当前页面需要的业务模块")]),t._v(" "),v("p",[t._v("按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载")]),t._v(" "),v("p",[t._v("webpack 提供了两个类似的技术，优先选择的方式是使用符合 ECMAScript 提案 的 import() 语法。第二种则是使用 webpack 特定的 require.ensure")]),t._v(" "),v("p",[t._v("3、使用资源预加载preload和资源预读取prefetch")]),t._v(" "),v("p",[t._v("preload让浏览器提前加载指定资源，需要执行时再执行，可以加速本页面的加载速度")]),t._v(" "),v("p",[t._v("prefetch告诉浏览器加载下一页面可能会用到的资源，可以加速下一个页面的加载速度")]),t._v(" "),v("p",[t._v("4、资源懒加载与资源预加载")]),t._v(" "),v("p",[t._v("资源延迟加载也称为懒加载，延迟加载资源或符合某些条件时才加载某些资源")]),t._v(" "),v("p",[t._v("资源预加载是提前加载用户所需的资源，保证良好的用户体验")]),t._v(" "),v("p",[t._v("资源懒加载和资源预加载都是一种错峰操作，在浏览器忙碌的时候不做操作，浏览器空间时，再加载资源，优化了网络性能")]),t._v(" "),v("h2",{attrs:{id:"五、减少重绘回流"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#五、减少重绘回流"}},[t._v("#")]),t._v(" 五、减少重绘回流")]),t._v(" "),v("p",[t._v("【样式设置】")]),t._v(" "),v("p",[t._v("1、避免使用层级较深的选择器，或其他一些复杂的选择器，以提高CSS渲染效率")]),t._v(" "),v("p",[t._v("2、避免使用CSS表达式，CSS表达式是动态设置CSS属性的强大但危险方法，它的问题就在于计算频率很快。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次")]),t._v(" "),v("p",[t._v("3、元素适当地定义高度或最小高度，否则元素的动态内容载入时，会出现页面元素的晃动或位置，造成回流")]),t._v(" "),v("p",[t._v("4、给图片设置尺寸。如果图片不设置尺寸，首次载入时，占据空间会从0到完全出现，上下左右都可能位移，发生回流")]),t._v(" "),v("p",[t._v("5、不要使用table布局，因为一个小改动可能会造成整个table重新布局。而且table渲染通常要3倍于同等元素时间")]),t._v(" "),v("p",[t._v("6、能够使用CSS实现的效果，尽量使用CSS而不使用JS实现")]),t._v(" "),v("p",[t._v("【渲染层】")]),t._v(" "),v("p",[t._v("1、此外，将需要多次重绘的元素独立为render layer渲染层，如设置absolute，可以减少重绘范围")]),t._v(" "),v("p",[t._v("2、对于一些进行动画的元素，使用硬件渲染，从而避免重绘和回流")]),t._v(" "),v("p",[t._v("【DOM优化】")]),t._v(" "),v("p",[t._v("1、缓存DOM")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[t._v("```sh\nconst div = document.getElementById('div')\n```\n")])])]),v("p",[t._v("由于查询DOM比较耗时，在同一个节点无需多次查询的情况下，可以缓存DOM")]),t._v(" "),v("p",[t._v("2、减少DOM深度及DOM数量")]),t._v(" "),v("p",[t._v("HTML 中标签元素越多，标签的层级越深，浏览器解析DOM并绘制到浏览器中所花的时间就越长，所以应尽可能保持 DOM 元素简洁和层级较少。")]),t._v(" "),v("p",[t._v("3、批量操作DOM")]),t._v(" "),v("p",[t._v("由于DOM操作比较耗时，且可能会造成回流，因此要避免频繁操作DOM，可以批量操作DOM，先用字符串拼接完毕，再用innerHTML更新DOM")]),t._v(" "),v("p",[t._v("4、批量操作CSS样式")]),t._v(" "),v("p",[t._v("通过切换class或者使用元素的style.csstext属性去批量操作元素样式")]),t._v(" "),v("p",[t._v("5、在内存中操作DOM")]),t._v(" "),v("p",[t._v("使用DocumentFragment对象，让DOM操作发生在内存中，而不是页面上")]),t._v(" "),v("p",[t._v("6、DOM元素离线更新")]),t._v(" "),v("p",[t._v("对DOM进行相关操作时，例、appendChild等都可以使用Document Fragment对象进行离线操作，带元素“组装”完成后再一次插入页面，或者使用display:none 对元素隐藏，在元素“消失”后进行相关操作")]),t._v(" "),v("p",[t._v("7、DOM读写分离")]),t._v(" "),v("p",[t._v("浏览器具有惰性渲染机制，连接多次修改DOM可能只触发浏览器的一次渲染。而如果修改DOM后，立即读取DOM。为了保证读取到正确的DOM值，会触发浏览器的一次渲染。因此，修改DOM的操作要与访问DOM分开进行")]),t._v(" "),v("p",[t._v("8、事件代理")]),t._v(" "),v("p",[t._v("事件代理是指将事件监听器注册在父级元素上，由于子元素的事件会通过事件冒泡的方式向上传播到父节点，因此，可以由父节点的监听函数统一处理多个子元素的事件")]),t._v(" "),v("p",[t._v("利用事件代理，可以减少内存使用，提高性能及降低代码复杂度")]),t._v(" "),v("p",[t._v("9、防抖和节流")]),t._v(" "),v("p",[t._v("使用函数节流（throttle）或函数去抖（debounce），限制某一个方法的频繁触发")]),t._v(" "),v("p",[t._v("10、及时清理环境")]),t._v(" "),v("p",[t._v("及时消除对象引用，清除定时器，清除事件监听器，创建最小作用域变量，可以及时回收内存")]),t._v(" "),v("h2",{attrs:{id:"六、性能更好的api"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#六、性能更好的api"}},[t._v("#")]),t._v(" 六、性能更好的API")]),t._v(" "),v("p",[t._v("1、用对选择器")]),t._v(" "),v("p",[t._v("选择器的性能排序如下所示，尽量选择性能更好的选择器")]),t._v(" "),v("div",{staticClass:"language-sh line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-sh"}},[v("code",[t._v("id选择器（"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#myid）")]),t._v("\n类选择器（.myclassname）\n标签选择器（div,h1,p）\n相邻选择器（h1+p）\n子选择器（ul "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" li）\n后代选择器（li a）\n通配符选择器（*）\n属性选择器（a"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("rel"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),v("span",{pre:!0,attrs:{class:"token string"}},[t._v('"external"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("）\n伪类选择器（a:hover,li:nth-child）\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br"),v("span",{staticClass:"line-number"},[t._v("7")]),v("br"),v("span",{staticClass:"line-number"},[t._v("8")]),v("br"),v("span",{staticClass:"line-number"},[t._v("9")]),v("br")])]),v("p",[t._v("2、使用requestAnimationFrame来替代setTimeout和setInterval")]),t._v(" "),v("p",[t._v("希望在每一帧刚开始的时候对页面进行更改，目前只有使用 requestAnimationFrame 能够保证这一点。使用 setTimeout 或者 setInterval 来触发更新页面的函数，该函数可能在一帧的中间或者结束的时间点上调用，进而导致该帧后面需要进行的事情没有完成，引发丢帧")]),t._v(" "),v("p",[t._v("3、使用IntersectionObserver来实现图片可视区域的懒加载")]),t._v(" "),v("p",[t._v("传统的做法中，需要使用scroll事件，并调用getBoundingClientRect方法，来实现可视区域的判断，即使使用了函数节流，也会造成页面回流。使用IntersectionObserver，则没有上述问题")]),t._v(" "),v("p",[t._v("4、使用web worker")]),t._v(" "),v("p",[t._v("客户端javascript一个基本的特性是单线程：比如，浏览器无法同时运行两个事件处理程序，它也无法在一个事件处理程序运行的时候触发一个计时器。Web Worker是HTML5提供的一个javascript多线程解决方案，可以将一些大计算量的代码交由web Worker运行，从而避免阻塞用户界面，在执行复杂计算和数据处理时，这个API非常有用")]),t._v(" "),v("p",[t._v("但是，使用一些新的API的同时，也要注意其浏览器兼容性")]),t._v(" "),v("h2",{attrs:{id:"七、webpack优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#七、webpack优化"}},[t._v("#")]),t._v(" 七、webpack优化")]),t._v(" "),v("p",[t._v("【打包公共代码】")]),t._v(" "),v("p",[t._v("使用CommonsChunkPlugin插件，将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。这会带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件")]),t._v(" "),v("p",[t._v("webpack 4 将移除 CommonsChunkPlugin, 取而代之的是两个新的配置项 optimization.splitChunks 和 optimization.runtimeChunk")]),t._v(" "),v("p",[t._v('通过设置 optimization.splitChunks.chunks: "all" 来启动默认的代码分割配置项')]),t._v(" "),v("p",[t._v("【动态导入和按需加载】")]),t._v(" "),v("p",[t._v("webpack提供了两种技术通过模块的内联函数调用来分离代码，优先选择的方式是，使用符合 ECMAScript 提案 的 import() 语法。第二种，则是使用 webpack 特定的 require.ensure")]),t._v(" "),v("p",[t._v("【剔除无用代码】")]),t._v(" "),v("p",[t._v("tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup")]),t._v(" "),v("p",[t._v("JS的tree shaking主要通过uglifyjs插件来完成，CSS的tree shaking主要通过purify CSS来实现的")]),t._v(" "),v("p",[t._v("【长缓存优化】")]),t._v(" "),v("p",[t._v("1、将hash替换为chunkhash，这样当chunk不变时，缓存依然有效")]),t._v(" "),v("p",[t._v("2、使用Name而不是id")]),t._v(" "),v("p",[t._v("每个 module.id 会基于默认的解析顺序(resolve order)进行增量。也就是说，当解析顺序发生变化，ID 也会随之改变")]),t._v(" "),v("p",[t._v("下面来使用两个插件解决这个问题。第一个插件是 NamedModulesPlugin，将使用模块的路径，而不是数字标识符。虽然此插件有助于在开发过程中输出结果的可读性，然而执行时间会长一些。第二个选择是使用 HashedModuleIdsPlugin，推荐用于生产环境构建")]),t._v(" "),v("p",[t._v("【公用代码内联】")]),t._v(" "),v("p",[t._v("使用html-webpack-inline-chunk-plugin插件将mainfest.js内联到html文件中")]),t._v(" "),v("h2",{attrs:{id:"_8、减少cookie传输"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8、减少cookie传输"}},[t._v("#")]),t._v(" 8、减少cookie传输")]),t._v(" "),v("p",[t._v("一方面，cookie包含在每次请求和响应中，太大的cookie会严重影响数据传输，因此哪些数据需要写入cookie需要慎重考虑，尽量减少cookie中传输的数据量。另一方面，对于某些静态资源的访问，如CSS、script等，发送cookie没有意义，可以考虑静态资源使用独立域名访问，避免请求静态资源时发送cookie，减少cookie传输次数。")]),t._v(" "),v("h2",{attrs:{id:"http标头-vary-accept-encoding-指定方法及其重要性分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http标头-vary-accept-encoding-指定方法及其重要性分析"}},[t._v("#")]),t._v(" HTTP标头“Vary:Accept-Encoding”指定方法及其重要性分析")]),t._v(" "),v("h3",{attrs:{id:"指定-vary-accept-encoding-标头的意义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#指定-vary-accept-encoding-标头的意义"}},[t._v("#")]),t._v(" 指定“Vary: Accept-Encoding”标头的意义")]),t._v(" "),v("p",[t._v("指定“Vary: Accept-Encoding”标头，用一句话来说明它的意义，就是“告诉代理服务器缓存两种版本的资源：压缩和非压缩，这有助于避免一些公共代理不能正确地检测Content-Encoding标头的问题。”更详细的解释是："),v("br"),t._v("\n一个网页从请求到响应的过程。正常情况下，“Response”的结果是可读文本，但并不是所有的服务器端都返回这样的正常的结果到用户端，有的返回一堆乱码，这显然是不正常的"),v("br")]),t._v(" "),v("p",[t._v("当浏览器发出一个请求时，会包含一些HTTP头信息，服务器会根据这些头信息决定返回什么样的东西（这是一个移动客户端吗？它能否处理压缩内容？它是否需要特定的语言支持？）。"),v("br")]),t._v(" "),v("p",[t._v("直接访问是好的，但现在网络使用了中间高速缓存（cache）和内容分发网络（CDN）。这就产生了一个问题，缓存如何使用头信息决定返回什么？它能否复制服务器端的决策逻辑？"),v("br")]),t._v(" "),v("p",[t._v("假如没有“Vary”头，那么如果由于某种原因，客户端有一个未压缩的版本在其缓存中的文件，它会不知道随后再次要求它的压缩版本，而不是只从缓存中使用未压缩的文件。——这就很好的解释了“Vary”头信息的重要意义。"),v("br")]),t._v(" "),v("p",[t._v("设想有两个客户，一个使用的旧浏览器不支持压缩，一个使用新的浏览器支持压缩，如果他们都请求同一个网页，那么取决于谁先请求，压缩或非压缩版本便存储在CDN上。这样问题就出现了，旧浏览器请求常规网页但获得缓存的压缩版本，而新浏览器会获得缓存的非压缩版本但尝试去“解压”它。无论哪种方式都是坏消息。解决方法是，源服务器回送“Vary: Accept-Encoding”。"),v("br")]),t._v(" "),v("p",[t._v("现在的中间CDN会存储独立的缓存条目，一个是Accept-encoding: gzip ，而如果你没有发送header，则存储另一个。"),v("br")]),t._v(" "),v("h3",{attrs:{id:"标头-vary-accept-encoding-指定方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#标头-vary-accept-encoding-指定方法"}},[t._v("#")]),t._v(" 标头“Vary:Accept-Encoding”指定方法")]),t._v(" "),v("p",[t._v("现在的新浏览器都支持压缩了，因此如果网站启用了GZip，可以无需再指定“Vary: Accept-Encoding”标头，不过指定“Vary: Accept-Encoding”标头会有更高的保险，而它并不需要你额外的开销，为什么不指定呢？下面是设置方法：")]),t._v(" "),v("div",{staticClass:"language-sh line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-sh"}},[v("code",[v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Apache/.htaccess")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("IfModule mod_headers.c"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("FilesMatch "),v("span",{pre:!0,attrs:{class:"token string"}},[t._v('".(js|css|xml|gz|html)$"')]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n        Header append Vary: Accept-Encoding\n    "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("/FilesMatch"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("/IfModule"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#  Nginx")]),t._v("\n  gzip_vary on\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br"),v("span",{staticClass:"line-number"},[t._v("7")]),v("br"),v("span",{staticClass:"line-number"},[t._v("8")]),v("br"),v("span",{staticClass:"line-number"},[t._v("9")]),v("br")])])])}),[],!1,null,null,null);s.default=e.exports}}]);